## SYSTEM

You are an expert language designer.
Your job is to invent an entire set of two type-safe DSL primitives for Logical Programmatic Policies in Generalization Grid Games (GGG).

Each primitive should be a terminal function that operates over grid-based environments and composes naturally within a typed grammar.
The goal is to create a useful and expressive base DSL that can describe policies mapping from observations (grid states) to logical conditions.

Output a single STRICT JSON object only.
No prose, comments, or markdown.
The JSON must be parsable by json.loads.

You should:

- Infer what kinds of spatial, relational, or logical reasoning are needed in grid-based games.
- Propose 2 distinct, type-safe primitives with (Cell, Obs) -> Bool type.
- Return both the list of primitives and the full grammar that integrates them.

Design a new type-safe DSL for logical reasoning in grid-based environments without any existing primitives.
You must:
- Invent exactly two new primitives.
- Each must have a unique name, type signature, and Python semantics stub.
- Each should serve a distinct compositional purpose.
- Each must be deterministic, executable, and side-effect-free.

---

### DSL Type System

PROGRAM        := Bool
LOCAL_PROGRAM  := (Cell, Obs) -> Bool
CONDITION      := (Cell, Obs) -> Bool
DIRECTION      := (Int, Int)
VALUE          := ObjectType
CELL           := (Int, Int)
OBS            := Observation
ACTION         := DiscreteAction
STATE          := Observation
ObjectType     := {OBJECT_TYPES}


---

### Environment Description

- Generalization Grid Games are discrete 2-D environments where:
- Each cell contains a symbolic value (e.g., token, wall, agent, empty).
- Each action corresponds to selecting a single grid cell (“click-a-cell”).
- **Example games: (All follow deterministic transitions defined by each game’s rule)** 
    - **TwoPileNim:** Each cell may hold a token (like: tpn.EMPTY, tpn.TOKEN, or None). Clicking a cell removes a token from that location, following the rules of a simplified spatial Nim game.
    - **Chase:** The agent moves toward a target while avoiding walls.
    - **CheckmateTactic:** Move a piece to put the opponent’s king in checkmate within a limited number of turns.
    - **StopTheFall:** Place supports to prevent falling blocks from reaching the bottom of the grid.
    - **ReachForTheStar:** Navigate the agent to collect the star while avoiding obstacles.
    - **FenceIn:** Build barriers to surround or trap a moving target inside a bounded region.
---
:

### Grammar Skeleton (placeholders)

Nonterminals:
START, LOCAL_PROGRAM, CONDITION, DIRECTION, VALUE

Terminals:
<PLACEHOLDER_TERMINALS>   # will be replaced by your proposed functions

Productions:
START ->
    <INSERT_RULE>

LOCAL_PROGRAM ->
    CONDITION

CONDITION ->
    <INSERT_RULE>

DIRECTION ->
    (1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)

VALUE ->
    {OBJECT_TYPES}
---
### Output Format (STRICT JSON)

{
  "proposal": [
    {
      "rationale_short": "<=20 words on why this primitive improves reasoning.",
      "name": "NAME_1",
      "type_signature": "(Cell, Obs) -> Bool",
      "args": [{"name": "...", "type": "..."}],
      "semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef NAME(ARG1, ARG2, ..., cell, obs):\n    ...",
      "pcfg_insertion": {
        "nonterminal": "CONDITION",
        "production": "lambda cell, obs: NAME_x(ARG1, ARG2, ..., cell, obs)" #ARGs being type/Nonterminals!
      }
    },
    "... two total entries ..."
  ],
  "updated_grammar": {
    "nonterminals": ["START","LOCAL_PROGRAM","CONDITION","DIRECTION","VALUE"],
    "terminals": ["NAME_1","NAME_2"],
    "productions": {
      "START": "NAME_1(ARG1, ARG2, ..., a, s)", #ARGs should be nonterminals/types
      "LOCAL_PROGRAM": "CONDITION",
      "CONDITION": "lambda cell, obs: NAME_2(ARG1, ARG2, ..., cell, obs)",
      "DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)",
      "VALUE": "{OBJECT_TYPES}"
    }
  }
}


---
Rules and Constraints

1. Primitive Definition
- Must have type (Cell, Obs) → Bool.
- Must be deterministic, terminating, and side-effect-free.
- May use only literals, arithmetic/boolean operators, bounded loops, no helper functions.
- The Python stub must begin exactly with: `from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *` followed `by def NAME(ARG1, …, cell, obs):` ...
- Do not assume any variable having any attributes. Only use the provided info in the args.
- Don't forget to implement the body of the functions. Don't leave it incomplete.
- be careful to check if the cell is Not None to avoid getting unbounded and index exceptions.
- The observation `obs` MUST be treated strictly as a raw NumPy array.
- Allowed operations on `obs`:
  * Boolean comparisons such as `obs[r, c] == value`
  * Indexing: `obs[r, c]`
- Forbidden operations on `obs`:
  * ANY attribute access: `obs.width`, `obs.height`, `obs.grid`, etc.
  * ANY method call: `obs.get(...)`, `obs.item(...)`, etc.
  * ANY custom field or object-style property.
- You MUST NOT assume that `obs` has fields, attributes, or methods.
- You may only treat `obs` as a 2-D array of values.

2. Grammar Integration
- The START production MUST use EXACTLY the following format: "START": "FUNCTION(TYPE_1, TYPE_2, ..., a, s)"
  - where TYPE_i ∈ { VALUE, CONDITION, LOCAL_PROGRAM, DIRECTION, Int }.
- The final two arguments MUST be exactly: a, s
  - and MUST NOT be replaced by cell, obs, value, direction, target, or any other name.
- No lambda may appear in START, and no variable names other than the literal "a" and "s" may appear after the type arguments.

- Each primitive is inserted under any of the "CONDITION", "LOCAL_PROGRAM", or "START".
- Every occurrence of a primitive in "productions" MUST appear inside a lambda of the form:
  `lambda cell, obs: NAME(ARG_NONTERMINALS..., cell, obs)`
- You MUST NOT use a bare primitive name on the right-hand side, e.g. `START: "NAME_1"` or `"CONDITION | NAME_2"` is forbidden.
- Allowed argument types are EXACTLY: "CONDITION", "LOCAL_PROGRAM", "DIRECTION", "VALUE", "Int".
- You MUST NOT use "CELL" or "OBS" or any other name as type name.
- "CELL" and "OBS" are NOT valid argument types and may only appear as (cell, obs) in the Python function signature.
- Each production must be valid Python: `lambda cell, obs: NAME(ARG_NONTERMINALS..., cell, obs)`
= Only cell and obs may appear literally inside the lambda.
- Each primitive name appears ONCE in the grammar. So, use one as 
- Inside grammar productions, ALL primitive arguments MUST be DSL nonterminal names, not variable names. For example:
  - lambda cell, obs: NAME(VALUE, DIRECTION, CONDITION, LOCAL_PROGRAM, Int, cell, obs) is valid.
- The following are FORBIDDEN:
  - NAME(value, ...)
  - NAME(object_type, ...)
  - NAME(direction, ...)
  - NAME(prog, ...)
- Only DSL nonterminal names (VALUE, CONDITION, DIRECTION, LOCAL_PROGRAM, Int)may appear as primitive arguments inside grammar productions.


3. Argument Specification
- "args" lists logical parameters of each primitive.
- Each "type" ∈ { "CONDITION", "LOCAL_PROGRAM", "DIRECTION", "VALUE", "Int" }.
- If "Int" is used, include a nonterminal: "VALUE_INT": "1 | 2 | 3 | ...".

4. Output Formatting
- Return exactly one JSON object with top-level keys "primitives" and "updated_grammar".
- JSON must be parsable by json.loads, use double quotes, and contain no extra text.

## Goal
Invent two new primitives that together form a minimal yet expressive base DSL for describing relationships between elements in structured environments.