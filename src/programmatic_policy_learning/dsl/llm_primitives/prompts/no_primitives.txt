## SYSTEM

You are designing a minimal yet expressive set of **terminal primitives** for a type-safe Domain-Specific Language (DSL) used in Logical Programmatic Policies for Generalization Grid Games.

Your task:
- Propose **exactly 5 new terminal functions** (Python primitives).
- Each primitive should be executable, deterministic, and compatible with the DSL’s type system.
- Together, they should form a cohesive minimal base capable of expressing common reasoning patterns (movement, scanning, condition checking, etc.).
- Output a single **strict JSON object only** — no prose, comments, or markdown.

Each primitive must be described with:
- A **short rationale** (≤20 words)
- A **unique name** in snake_case
- **Arguments** with type names drawn from the DSL type system
- A **Python semantics stub** (self-contained)
- A **grammar insertion** showing how it appears in the grammar (using `lambda cell, obs: ...` form)
- Type safety and composability with the rest of the DSL

---

### DSL Type System

PROGRAM        := Bool  
LOCAL_PROGRAM  := (Cell, Obs) -> Bool  
CONDITION      := (Cell, Obs) -> Bool  
DIRECTION      := (Int, Int)  
VALUE          := Int  
CELL           := (Int, Int)  
OBS            := Observation  
ACTION         := DiscreteAction  
STATE          := Observation  

---

### Grammar Skeleton (placeholders)

Nonterminals:
START, LOCAL_PROGRAM, CONDITION, DIRECTION, VALUE

Terminals:
<PLACEHOLDER_TERMINALS>   # will be replaced by your proposed functions

Productions:
START ->
    <INSERT_RULE_1> | <INSERT_RULE_2> | <INSERT_RULE_3>

LOCAL_PROGRAM ->
    CONDITION | <INSERT_RULE_4>

CONDITION ->
    <INSERT_RULE_5> | <INSERT_RULE_6> | <INSERT_RULE_7>

DIRECTION ->
    (1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)

VALUE ->
    {OBJECT_TYPES}

---

### Environment Description

Generalization Grid Games are grid-worlds where:
- Each cell holds a discrete value (e.g., EMPTY, TOKEN, WALL).
- The observation (Obs) is a full grid.
- An action selects a grid cell (“click”).
- Transitions are deterministic and vary by game (e.g., Chase, Nim, CheckmateTactic, etc.).

The DSL defines **Boolean programs** that express logical spatial conditions and can generalize across tasks.

---

### Output Format (STRICT JSON)

{
  "terminals": [
    {
      "rationale_short": "STRING (≤20 words)",
      "name": "snake_case_name",
      "type_signature": "Bool",
      "args": [{"name": "arg_name", "type": "TYPE"}],
      "semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef name(ARG1, ARG2, ..., cell, obs):\\n    ...",
      "pcfg_insertion": {
        "nonterminal": "START|LOCAL_PROGRAM|CONDITION",
        "production": "lambda cell, obs: name(ARG1, ARG2, ..., cell, obs)"
      }
    },
    ...  // exactly 5 entries
  ],
  "updated_grammar": {
    "nonterminals": ["START", "LOCAL_PROGRAM", "CONDITION", "DIRECTION", "VALUE"],
    "terminals": ["<NAMES_OF_ALL_FIVE_FUNCTIONS>"],
    "productions": {
      "START": "<INSERT_RULES_USING_NEW_TERMINALS>",
      "LOCAL_PROGRAM": "<INSERT_RULES_USING_NEW_TERMINALS>",
      "CONDITION": "<INSERT_RULES_USING_NEW_TERMINALS>",
      "DIRECTION": "(1,0)|(0,1)|(-1,0)|(0,-1)|(1,1)|(-1,1)|(1,-1)|(-1,-1)",
      "VALUE": "{OBJECT_TYPES}"
    }
  }
}

---

### Safety and Syntax Rules

- No external imports beyond the provided `import *`.
- All functions must be pure and side-effect-free.
- No undefined names, constants, or undeclared variables.
- Each `production` must reference only valid nonterminals (CONDITION, DIRECTION, VALUE, LOCAL_PROGRAM) and variables (cell, obs, a, s).
- Arguments in the `semantics_py_stub` must match those in the `production`.
- Output **only one JSON object**.
- The functions together should form a coherent, compositional DSL.

---

### Goal

Design 5 complementary DSL primitives that replace all existing terminals — forming a compact, expressive foundation for building logical policies over grid worlds.
