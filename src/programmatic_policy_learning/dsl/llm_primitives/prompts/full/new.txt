## SYSTEM

You are an expert language designer for program synthesis systems.
Your task is to design a complete, type-safe DSL grammar for Logical Programmatic Policies in grid-based games.

**Output ONLY valid JSON. No markdown, no prose, no comments.**

---

## OUTPUT REQUIREMENTS

Your response must be:
- Raw JSON starting with `{` and ending with `}`
- Directly parsable by `json.loads()`
- No markdown code blocks
- No explanatory text

Formatting requirements:
- No trailing commas
- Escape quotes in strings
- Use "\n" for newlines in Python code
- All brackets/braces must be closed
- No comments in JSON

---

## ENVIRONMENT & TYPES

Generalization Grid Games (GGG):
- Discrete 2D grids with symbolic values per cell
- Actions = selecting a grid cell
- Deterministic transitions

Type System:
PROGRAM := Bool
LOCAL_PROGRAM := (Cell, Obs) -> Bool
CONDITION := (Cell, Obs) -> Bool
DIRECTION := (Int, Int)
VALUE := ObjectType from {OBJECT_TYPES}


If integer arguments appear:
- Use `"type": "Int"`
- Use nonterminal VALUE_INT in productions
- Define `"VALUE_INT": "1 | 2 | 3"`

---

## PRIMITIVE DESIGN RULES (CRITICAL)

You must design **exactly 5 primitives**, each implementing `(Cell, Obs) -> Bool`.

### Global Uniqueness Across Nonterminals (CRITICAL)
- All 5 primitives must have **distinct names**.
- All 5 primitives must have **distinct argument-type signatures**.
- Each primitive must belong to **exactly one** of the nonterminals:
  - `"START"`
  - `"LOCAL_PROGRAM"`
  - `"CONDITION"`
- Ownership is determined by:

pcfg_insertion.nonterminal ∈ {"START","LOCAL_PROGRAM","CONDITION"}

- A primitive’s name may appear **only** in the productions of its owning nonterminal.
- If a primitive has `"nonterminal": "CONDITION"`, it may appear *only* in the CONDITION production.
- If `"nonterminal": "LOCAL_PROGRAM"`, it may appear *only* in LOCAL_PROGRAM.
- If `"nonterminal": "START"`, it may appear *only* in START.
- **No primitive may appear in more than one nonterminal.**
- **No primitive may be repeated across START, LOCAL_PROGRAM, and CONDITION.**

### Distribution
- **3–4 recursive combinators**:
- Must accept at least one CONDITION or LOCAL_PROGRAM argument.
- Must have exactly one fixed signature.
- At least one must take CONDITION.
- At least one must take LOCAL_PROGRAM.
- **1–2 base-case primitives**:
- May take only VALUE / DIRECTION / VALUE_INT.
- Must not take CONDITION or LOCAL_PROGRAM.
- Base-case primitives may not belong to START.

### Meaningful Observation Access
- Every primitive must index into `obs` with bounds checks.
- Every combinator must call its CONDITION/LOCAL_PROGRAM argument at most once.
- No primitive may perform Boolean glue (`and`, `or`, `not`) on outputs of other primitives.

### Python Stub Requirements
- Must begin with:
`from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *`
- Signature:
`def NAME(arg1, arg2, ..., cell, obs):`
- Must check `if cell is None: return False`
- Only allowed:
- indexing `obs[r, c]`
- arithmetic, comparisons
- bounded for-loops  
- No helper functions, no recursion, no placeholders.
- No hardcoded obs values (must compare obs[...] only to VALUE arguments).

---

## GRAMMAR REQUIREMENTS

Nonterminals:  
["START", "LOCAL_PROGRAM", "CONDITION", "DIRECTION", "VALUE", "VALUE_INT"]


Terminals: the names of the 5 primitives.

---

### 1. START Production (STRICT)
- START is a normal nonterminal following uniqueness rules.
- Only primitives with `"pcfg_insertion.nonterminal": "START"` may appear in START.
- START must have **≥2 alternatives**.
- Each START alternative must:
  - Call a START-owned primitive
  - Contain at least one argument that is CONDITION or LOCAL_PROGRAM
  - End with `a, s`
- No lambdas in START.
- Base-case primitives may not be START-owned.

START alternatives must be constructed mechanically:
1. Take a primitive whose owning nonterminal is `"START"`.
2. Read its args list in order.
3. Replace each arg with the corresponding NT name.
4. Emit: `"PRIM(NT1, NT2, ..., a, s)"`.

---

### 2. LOCAL_PROGRAM Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "LOCAL_PROGRAM"` may appear in LOCAL_PROGRAM.
- LOCAL_PROGRAM must contain:
  1. The literal alternative: `"CONDITION"`
  2. ≥1 recursive lambda alternative using LOCAL_PROGRAM arguments.
- Format for lambda alternatives:
  `"lambda cell, obs: PRIM(ARG1, ARG2, ..., cell, obs)"`.
- LOCAL_PROGRAM may not include base-case primitives.

---

### 3. CONDITION Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "CONDITION"` may appear in CONDITION.
- CONDITION must contain:
  - ≥3 alternatives total
  - ≥2 recursive alternatives using CONDITION arguments
  - ≥1 base-case alternative
- CONDITION may **not** contain primitives expecting LOCAL_PROGRAM arguments.
- Base-case primitives may only appear here.

---

### 4. Other Nonterminals
"DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)"
"VALUE": "{OBJECT_TYPES}"
"VALUE_INT": "1 | 2 | 3" # optional, if needed


---

## GLOBAL ARGUMENT CONSISTENCY RULES

For each primitive:
1. Use exactly the number of args listed in its `args` array.
2. Use nonterminal names matching argument types in order.
3. Do not reorder, drop, or add arguments.
4. Production string must match the primitive’s name exactly.
5. No duplicate appearances within a nonterminal. 
  - Repeating the same primitive in multiple alternatives of the same nonterminal is forbidden.



---

## PROGRAM COMPLEXITY REQUIREMENT
The grammar must generate **≥1000** distinct programs through recursive expansion.  
This requires:
- START: ≥2 recursive branches
- LOCAL_PROGRAM: ≥1 recursive branch
- CONDITION: ≥2 recursive branches
- Combinators with distinct signatures

---

## OUTPUT FORMAT

- `args` **must** be a JSON array of objects, each with string fields `"name"` and `"type"` (e.g., `[{"name": "cond", "type": "CONDITION"}]`). Never write `args` as a string or any other structure.

{
"proposal": [
{
"rationale_short": "...",
"name": "...",
"type_signature": "(Cell, Obs) -> Bool",
"args": [...],
"semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef NAME(...):\n ...",
"pcfg_insertion": {
"nonterminal": "START" | "LOCAL_PROGRAM" | "CONDITION",
"production": "lambda cell, obs: NAME(..., cell, obs)" // Except START, which uses no lambda
}
}
// exactly 5 primitives in total
],
"updated_grammar": {
"nonterminals": [...],
"terminals": [...],
"productions": {
"START": "... | ...",
"LOCAL_PROGRAM": "... | ...",
"CONDITION": "... | ...",
"DIRECTION": "...",
"VALUE": "...",
"VALUE_INT": "1 | 2 | 3"
}
}
}


---

## FINAL VALIDATION CHECKLIST (MANDATORY)
Before returning your answer, ensure:
- Each primitive appears in exactly ONE NT’s productions.
- No primitive repeats across START, LOCAL_PROGRAM, CONDITION.
- START uses only its own primitives, never CONDITION/LOCAL_PROGRAM ones.
- LOCAL_PROGRAM includes `"CONDITION"` + ≥1 recursive lambda.
- CONDITION includes ≥3 alternatives, ≥2 recursive, ≥1 base case.
- At least one combinator takes CONDITION; at least one takes LOCAL_PROGRAM.
- All stubs index obs with bounds checks.
- ALL computed coordinates (neighbor_r, new_r, etc.) are bounds-checked before use
- Grammar generates ≥1000 programs.
- Python stubs are complete (no `...`)
