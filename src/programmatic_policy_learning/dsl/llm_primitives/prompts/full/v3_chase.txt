## SYSTEM

You are an expert language designer for program synthesis systems.
Your task is to design a complete, type-safe DSL grammar for Logical Programmatic Policies in grid-based games.

**Output ONLY valid JSON. No markdown, no prose, no comments.**

---

## OUTPUT REQUIREMENTS

Your response must be:
- Raw JSON starting with `{` and ending with `}`
- Directly parsable by `json.loads()`
- No markdown code blocks
- No explanatory text

Formatting requirements:
- No trailing commas
- Escape quotes in strings
- Use "\n" for newlines in Python code
- All brackets/braces must be closed
- No comments in JSON

---

## ENVIRONMENT & TYPES

Generalization Grid Games (GGG):
- Discrete 2D grids with symbolic values per cell
- Actions = selecting a grid cell
- Deterministic transitions

Type System:
PROGRAM := Bool
LOCAL_PROGRAM := (Cell, Obs) -> Bool
CONDITION := (Cell, Obs) -> Bool
DIRECTION := (Int, Int)
VALUE := ObjectType from {OBJECT_TYPES}


If integer arguments appear:
- Use `"type": "Int"`
- Use nonterminal VALUE_INT in productions
- Define `"VALUE_INT": "1 | 2 | 3 ..."`
- The range for VALUE_INT should be chosen automatically by the model based on the needs of the primitives. It must not default to {1,2,3} if a larger or different range is required.

---

## PRIMITIVE DESIGN RULES (CRITICAL)

You must design **exactly 5-10 primitives**, each implementing `(Cell, Obs) -> Bool`.
- Choose the number automatically based on the structure needed to express useful behaviors in the trajectories.

### Core expressiveness requirement
At least two primitives must explicitly capture spatial relationships between grid values (i.e., it must compute something involving the relative position or  arrangement of VALUEs).
At least one primitive must capture a relational or logical dependency.
Across all primitives, there must be meaningful coverage of spatial, directional, distance-based, and obstacle-aware reasoning patterns (inspired by demonstration-inferred hints).


### Global Uniqueness Across Nonterminals (CRITICAL)
- All primitives must have **distinct names**.
- Each primitive must belong to **exactly one** of the nonterminals:
  - `"START"`
  - `"LOCAL_PROGRAM"`
  - `"CONDITION"`
- Ownership is determined by: pcfg_insertion.nonterminal ∈ {"START","LOCAL_PROGRAM","CONDITION"}
- A primitive’s name may appear **only** in the productions of its owning nonterminal.
- If a primitive has `"nonterminal": "CONDITION"`, it may appear *only* in the CONDITION production.
- If `"nonterminal": "LOCAL_PROGRAM"`, it may appear *only* in LOCAL_PROGRAM.
- If `"nonterminal": "START"`, it may appear *only* in START.
- **No primitive may appear in more than one nonterminal.**
- **No primitive may be repeated across START, LOCAL_PROGRAM, and CONDITION.**
- No primitive may exist solely to combine Boolean results of other primitives.

### Distribution
- **3–4 recursive combinators**:
- Must accept at least one CONDITION or LOCAL_PROGRAM argument.
- Must have exactly one fixed signature.
- At least one must take CONDITION.
- At least one must take LOCAL_PROGRAM.
- **1–2 base-case primitives**:
- May take only VALUE / DIRECTION / VALUE_INT.
- Must not take CONDITION or LOCAL_PROGRAM.
- Base-case primitives may not belong to START.

### Meaningful Observation Access
- Every primitive must index into `obs` with bounds checks.
- No primitive may perform Boolean glue (`and`, `or`, `not`) on outputs of other primitives.

### Prohibited trivial primitives
- No primitive may be a Boolean combiner in disguise...

### Python Stub Requirements
- Signature:
`def NAME(arg1, arg2, ..., cell, obs):`
- Must check `if cell is None: return False`
- Only allowed:
  - indexing `obs[r, c]`
  - arithmetic, comparisons
  - bounded for-loops  
- No helper functions, no recursion, no placeholders.
- No hardcoded obs values (must compare obs[...] only to VALUE arguments).

---

## DEMONSTRATION-INFERRED FEATURES (HINTS)

Below is a summary of patterns extracted from a set of expert trajectories.
These are NOT DSL primitives, but they describe spatial relations frequently relevant to decision-making.

### High-frequency relational patterns:
- The agent frequently moves to reduce the Manhattan (grid) distance to the target.
- The agent often positions itself to be on the same row or column as the target before closing in.
- The agent tends to approach the target from the direction with the least obstacles or open space.
- The agent avoids moving into positions where obstacles (trees) would block a direct path to the target.

### Useful directional / asymmetry relations:
- The agent often moves to align itself horizontally or vertically with the target before making the final approach.
- When the target is near a boundary or corner, the agent approaches from the direction that minimizes the target's escape options.
- The agent prefers to approach the target from the side with more open space, avoiding being separated by obstacles.
- There is a tendency to approach the target from behind or from the side, rather than head-on if the target is near a wall.

### Example state–action correlations:
- When the agent is diagonally offset from the target, it chooses actions that reduce both the x and y distance, often prioritizing the axis with the greater gap.
- If the target is adjacent to a boundary, the agent moves to block potential escape routes along the open axis.
- When the agent is one step away (adjacent) to the target, it moves directly onto the target's cell.
- If the agent and target are separated by an obstacle, the agent moves around the obstacle rather than attempting to move through it.

### Frequently observed local spatial configurations:
- The agent and target are often separated by a single row or column, with the agent moving to close this gap.
- The agent frequently positions itself so that there are no obstacles between itself and the target along the approach axis.
- When the target is in a corner, the agent approaches along the open edge, effectively trapping the target.
- The agent avoids being diagonally adjacent to the target if a direct approach is possible.

### Observed distance thresholds or step ranges:
- The agent consistently acts to reduce the distance to the target to zero, moving stepwise closer each turn.
- When within 2-3 steps of the target, the agent prioritizes moves that will quickly bring it adjacent to the target.
- The agent rarely takes detours unless blocked by obstacles, indicating a preference for the shortest available path.
- When the target is within 1 step of a boundary, the agent increases pressure by moving to cut off escape along the open axis.

---

## GRAMMAR REQUIREMENTS

Nonterminals:  
["START", "LOCAL_PROGRAM", "CONDITION", "DIRECTION", "VALUE", "VALUE_INT"]


Terminals: the names of all primitives.

---

### 1. START Production (STRICT)
- START is a normal nonterminal following uniqueness rules.
- Only primitives with `"pcfg_insertion.nonterminal": "START"` may appear in START.
- START must have **≥2 alternatives**.
- Each START alternative must:
  - Call a START-owned primitive
  - Contain at least one argument that is CONDITION or LOCAL_PROGRAM
  - End with `a, s`
- No lambdas in START.
- Base-case primitives may not be START-owned.

START alternatives must be constructed mechanically:
1. Take a primitive whose owning nonterminal is `"START"`.
2. Read its args list in order.
3. Replace each arg with the corresponding NT name.
4. Emit: `"PRIM(NT1, NT2, ..., a, s)"`.

---

### 2. LOCAL_PROGRAM Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "LOCAL_PROGRAM"` may appear in LOCAL_PROGRAM.
- LOCAL_PROGRAM must contain:
  1. The literal alternative: `"CONDITION"`
  2. ≥1 recursive lambda alternative using LOCAL_PROGRAM arguments.
- Format for lambda alternatives:
  `"lambda cell, obs: PRIM(ARG1, ARG2, ..., cell, obs)"`.
- LOCAL_PROGRAM may not include base-case primitives.

---

### 3. CONDITION Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "CONDITION"` may appear in CONDITION.
- CONDITION must contain:
  - ≥3 alternatives total
  - ≥2 recursive alternatives using CONDITION arguments
  - ≥1 base-case alternative
- CONDITION may **not** contain primitives expecting LOCAL_PROGRAM arguments.
- Base-case primitives may only appear here.

---

### 4. Other Nonterminals
"DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)"
"VALUE": "{OBJECT_TYPES}"
"VALUE_INT": "1 | 2 | 3 ..." 


---

## GLOBAL ARGUMENT CONSISTENCY RULES

For each primitive:
1. Use exactly the number of args listed in its `args` array.
2. Use nonterminal names matching argument types in order.
3. Do not reorder, drop, or add arguments.
4. Production string must match the primitive’s name exactly.
5. No duplicate appearances within a nonterminal. 
  - Repeating the same primitive in multiple alternatives of the same nonterminal is forbidden.



---

## PROGRAM COMPLEXITY REQUIREMENT
The grammar must generate **≥1000** distinct programs through recursive expansion.  
This requires:
- START: ≥2 recursive branches
- LOCAL_PROGRAM: ≥1 recursive branch
- CONDITION: ≥2 recursive branches

---

## OUTPUT FORMAT

- `args` **must** be a JSON array of objects, each with string fields `"name"` and `"type"` (e.g., `[{"name": "cond", "type": "CONDITION"}]`). Never write `args` as a string or any other structure.

{
"proposal": [
{
"rationale_short": "...",
"name": "...",
"type_signature": "(Cell, Obs) -> Bool",
"args": [...],
"semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef NAME(...):\n ...",
"pcfg_insertion": {
"nonterminal": "START" | "LOCAL_PROGRAM" | "CONDITION",
"production": "lambda cell, obs: NAME(..., cell, obs)" // Except START, which uses no lambda
}
}
// exactly all primitives in totall
],
"updated_grammar": {
"nonterminals": [...],
"terminals": [...],
"productions": {
"START": "... | ...",
"LOCAL_PROGRAM": "... | ...",
"CONDITION": "... | ...",
"DIRECTION": "...",
"VALUE": "...",
"VALUE_INT": "1 | 2 | 3 ..."
}
}
}


---

## FINAL VALIDATION CHECKLIST (MANDATORY)
Before returning your answer, ensure:
- Each primitive appears in exactly ONE NT’s productions.
- No primitive repeats across START, LOCAL_PROGRAM, CONDITION.
- START uses only its own primitives, never CONDITION/LOCAL_PROGRAM ones.
- LOCAL_PROGRAM includes `"CONDITION"` + ≥1 recursive lambda.
- CONDITION and LOCAL_PROGRAM have lambda expressions. NO lambda in START.
- CONDITION includes ≥3 alternatives, ≥2 recursive, ≥1 base case.
- At least one combinator takes CONDITION; at least one takes LOCAL_PROGRAM.
- All stubs index obs with bounds checks.
- ALL computed coordinates (neighbor_r, new_r, etc.) are bounds-checked before use
- Grammar generates ≥1000 programs.
- Python stubs are complete (no `...`)
