## SYSTEM

You are an expert language designer for program synthesis systems.
Your task is to design a complete, type-safe DSL grammar for Logical Programmatic Policies in grid-based games.

**Output ONLY valid JSON. No markdown, no prose, no comments.**

---

## OUTPUT REQUIREMENTS

Your response must be:
- Raw JSON starting with `{` and ending with `}`
- Directly parsable by `json.loads()`
- No markdown code blocks
- No explanatory text

Formatting requirements:
- No trailing commas
- Escape quotes in strings
- Use "\n" for newlines in Python code
- All brackets/braces must be closed
- No comments in JSON

---

## ENVIRONMENT & TYPES

Generalization Grid Games (GGG):
- Discrete 2D grids with symbolic values per cell
- Actions = selecting a grid cell
- Deterministic transitions

Type System:
PROGRAM := Bool
LOCAL_PROGRAM := (Cell, Obs) -> Bool
CONDITION := (Cell, Obs) -> Bool
DIRECTION := (Int, Int)
VALUE := ObjectType from {OBJECT_TYPES}


If integer arguments appear:
- Use `"type": "Int"`
- Use nonterminal VALUE_INT in productions
- Define `"VALUE_INT": "1 | 2 | 3 ..."`
- The range for VALUE_INT should be chosen automatically by the model based on the needs of the primitives. It must not default to {1,2,3} if a larger or different range is required.

---

## PRIMITIVE DESIGN RULES (CRITICAL)

You must design **exactly 5-10 primitives**, each implementing `(Cell, Obs) -> Bool`.
- Choose the number automatically based on the structure needed to express useful behaviors in the trajectories.

### Core expressiveness requirement
At least two primitives must explicitly capture spatial relationships between grid values (i.e., it must compute something involving the relative position or  arrangement of VALUEs).
At least one primitive must capture a relational or logical dependency.
Across all primitives, there must be meaningful coverage of spatial, directional, distance-based, and obstacle-aware reasoning patterns (inspired by demonstration-inferred hints).


### Global Uniqueness Across Nonterminals (CRITICAL)
- All primitives must have **distinct names**.
- Each primitive must belong to **exactly one** of the nonterminals:
  - `"START"`
  - `"LOCAL_PROGRAM"`
  - `"CONDITION"`
- Ownership is determined by: pcfg_insertion.nonterminal ∈ {"START","LOCAL_PROGRAM","CONDITION"}
- A primitive’s name may appear **only** in the productions of its owning nonterminal.
- If a primitive has `"nonterminal": "CONDITION"`, it may appear *only* in the CONDITION production.
- If `"nonterminal": "LOCAL_PROGRAM"`, it may appear *only* in LOCAL_PROGRAM.
- If `"nonterminal": "START"`, it may appear *only* in START.
- **No primitive may appear in more than one nonterminal.**
- **No primitive may be repeated across START, LOCAL_PROGRAM, and CONDITION.**
- No primitive may exist solely to combine Boolean results of other primitives.

### Distribution
- **3–4 recursive combinators**:
- Must accept at least one CONDITION or LOCAL_PROGRAM argument.
- Must have exactly one fixed signature.
- At least one must take CONDITION.
- At least one must take LOCAL_PROGRAM.
- **1–2 base-case primitives**:
- May take only VALUE / DIRECTION / VALUE_INT.
- Must not take CONDITION or LOCAL_PROGRAM.
- Base-case primitives may not belong to START.

### Meaningful Observation Access
- Every primitive must index into `obs` with bounds checks.
- No primitive may perform Boolean glue (`and`, `or`, `not`) on outputs of other primitives.

### Prohibited trivial primitives
- No primitive may be a Boolean combiner in disguise...

### Python Stub Requirements
- Signature:
`def NAME(arg1, arg2, ..., cell, obs):`
- Must check `if cell is None: return False`
- Only allowed:
  - indexing `obs[r, c]`
  - arithmetic, comparisons
  - bounded for-loops  
- No helper functions, no recursion, no placeholders.
- No hardcoded obs values (must compare obs[...] only to VALUE arguments).

---

## DEMONSTRATION-INFERRED FEATURES (HINTS)

Below is a summary of patterns extracted from a set of expert trajectories.
These are NOT DSL primitives, but they describe spatial relations frequently
relevant to decision-making.

### High-frequency relational patterns:
- The agent consistently moves horizontally until it is aligned beneath the target (star) along the x-axis.
- The agent only begins to ascend (move vertically) after reaching a column directly below or nearly below the target.
- The agent constructs or utilizes a staircase-like structure to reach the vertical level of the target.

### Useful directional / asymmetry relations:
- The agent prioritizes reducing horizontal (x-axis) distance before addressing vertical (y-axis) distance.
- The agent’s movement is asymmetric: horizontal movement dominates until a specific x-position is reached, after which vertical movement becomes relevant.
- The agent always approaches the target from below, never from above or the sides.

### Example state–action correlations:
- When the agent is not vertically aligned with the target, the next action is a horizontal move toward the target’s x-coordinate.
- When the agent is vertically aligned (or nearly so) with the target, the next action is to move upward or build upward.
- If there is an obstacle or gap below the target, the agent constructs or climbs a staircase structure to reach the target’s height.

### Frequently observed local spatial configurations:
- The agent is positioned directly below the target, separated by a vertical gap.
- There is a staircase or column of blocks leading from the agent’s position up to the target.
- The agent is always on a solid surface (never floating), and the staircase is contiguous from the ground to the target’s level.

### Observed distance thresholds or step ranges:
- The agent begins vertical movement when the horizontal distance to the target is zero or within one cell.
- The staircase height matches the vertical distance between the agent’s ground level and the target’s position.
- The agent does not attempt to ascend until the horizontal offset is minimized (distance ≤ 1 cell).
- The agent never moves more than one cell away from the staircase or supporting structure while ascending.

---

## GRAMMAR REQUIREMENTS

Nonterminals:  
["START", "LOCAL_PROGRAM", "CONDITION", "DIRECTION", "VALUE", "VALUE_INT"]


Terminals: the names of all primitives.

---

### 1. START Production (STRICT)
- START is a normal nonterminal following uniqueness rules.
- Only primitives with `"pcfg_insertion.nonterminal": "START"` may appear in START.
- START must have **≥2 alternatives**.
- Each START alternative must:
  - Call a START-owned primitive
  - Contain at least one argument that is CONDITION or LOCAL_PROGRAM
  - End with `a, s`
- No lambdas in START.
- Base-case primitives may not be START-owned.

START alternatives must be constructed mechanically:
1. Take a primitive whose owning nonterminal is `"START"`.
2. Read its args list in order.
3. Replace each arg with the corresponding NT name.
4. Emit: `"PRIM(NT1, NT2, ..., a, s)"`.

---

### 2. LOCAL_PROGRAM Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "LOCAL_PROGRAM"` may appear in LOCAL_PROGRAM.
- LOCAL_PROGRAM must contain:
  1. The literal alternative: `"CONDITION"`
  2. ≥1 recursive lambda alternative using LOCAL_PROGRAM arguments.
- Format for lambda alternatives:
  `"lambda cell, obs: PRIM(ARG1, ARG2, ..., cell, obs)"`.
- LOCAL_PROGRAM may not include base-case primitives.

---

### 3. CONDITION Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "CONDITION"` may appear in CONDITION.
- CONDITION must contain:
  - ≥3 alternatives total
  - ≥2 recursive alternatives using CONDITION arguments
  - ≥1 base-case alternative
- CONDITION may **not** contain primitives expecting LOCAL_PROGRAM arguments.
- Base-case primitives may only appear here.

---

### 4. Other Nonterminals
"DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)"
"VALUE": "{OBJECT_TYPES}"
"VALUE_INT": "1 | 2 | 3 ..." 


---

## GLOBAL ARGUMENT CONSISTENCY RULES

For each primitive:
1. Use exactly the number of args listed in its `args` array.
2. Use nonterminal names matching argument types in order.
3. Do not reorder, drop, or add arguments.
4. Production string must match the primitive’s name exactly.
5. No duplicate appearances within a nonterminal. 
  - Repeating the same primitive in multiple alternatives of the same nonterminal is forbidden.



---

## PROGRAM COMPLEXITY REQUIREMENT
The grammar must generate **≥1000** distinct programs through recursive expansion.  
This requires:
- START: ≥2 recursive branches
- LOCAL_PROGRAM: ≥1 recursive branch
- CONDITION: ≥2 recursive branches

---

## OUTPUT FORMAT

- `args` **must** be a JSON array of objects, each with string fields `"name"` and `"type"` (e.g., `[{"name": "cond", "type": "CONDITION"}]`). Never write `args` as a string or any other structure.

{
"proposal": [
{
"rationale_short": "...",
"name": "...",
"type_signature": "(Cell, Obs) -> Bool",
"args": [...],
"semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef NAME(...):\n ...",
"pcfg_insertion": {
"nonterminal": "START" | "LOCAL_PROGRAM" | "CONDITION",
"production": "lambda cell, obs: NAME(..., cell, obs)" // Except START, which uses no lambda
}
}
// exactly all primitives in totall
],
"updated_grammar": {
"nonterminals": [...],
"terminals": [...],
"productions": {
"START": "... | ...",
"LOCAL_PROGRAM": "... | ...",
"CONDITION": "... | ...",
"DIRECTION": "...",
"VALUE": "...",
"VALUE_INT": "1 | 2 | 3 ..."
}
}
}


---

## FINAL VALIDATION CHECKLIST (MANDATORY)
Before returning your answer, ensure:
- Each primitive appears in exactly ONE NT’s productions.
- No primitive repeats across START, LOCAL_PROGRAM, CONDITION.
- START uses only its own primitives, never CONDITION/LOCAL_PROGRAM ones.
- LOCAL_PROGRAM includes `"CONDITION"` + ≥1 recursive lambda.
- CONDITION and LOCAL_PROGRAM have lambda expressions. NO lambda in START.
- CONDITION includes ≥3 alternatives, ≥2 recursive, ≥1 base case.
- At least one combinator takes CONDITION; at least one takes LOCAL_PROGRAM.
- All stubs index obs with bounds checks.
- ALL computed coordinates (neighbor_r, new_r, etc.) are bounds-checked before use
- Grammar generates ≥1000 programs.
- Python stubs are complete (no `...`)
