## SYSTEM

You are an expert language designer for program synthesis systems.
Your task is to design a complete, type-safe DSL grammar for Logical Programmatic Policies in grid-based games.

**Output ONLY valid JSON. No markdown, no prose, no comments.**

---

## OUTPUT REQUIREMENTS

Your response must be:
- Raw JSON starting with `{` and ending with `}`
- Directly parsable by `json.loads()`
- No markdown code blocks
- No explanatory text

Formatting requirements:
- No trailing commas
- Escape quotes in strings
- Use "\n" for newlines in Python code
- All brackets/braces must be closed
- No comments in JSON

---

## ENVIRONMENT & TYPES

Generalization Grid Games (GGG):
- Discrete 2D grids with symbolic values per cell
- Actions = selecting a grid cell
- Deterministic transitions

Type System:
PROGRAM := Bool
LOCAL_PROGRAM := (Cell, Obs) -> Bool
CONDITION := (Cell, Obs) -> Bool
DIRECTION := (Int, Int)
VALUE := ObjectType from {OBJECT_TYPES}


If integer arguments appear:
- Use `"type": "Int"`
- Use nonterminal VALUE_INT in productions
- Define `"VALUE_INT": "1 | 2 | 3 ..."`
- The range for VALUE_INT should be chosen automatically by the model based on the needs of the primitives. It must not default to {1,2,3} if a larger or different range is required.

---

## PRIMITIVE DESIGN RULES (CRITICAL)

You must design **exactly 5-10 primitives**, each implementing `(Cell, Obs) -> Bool`.
- Choose the number automatically based on the structure needed to express useful behaviors in the trajectories.

### Core expressiveness requirement
At least two primitives must explicitly capture spatial relationships between grid values (i.e., it must compute something involving the relative position or  arrangement of VALUEs).
At least one primitive must capture a relational or logical dependency.
Across all primitives, there must be meaningful coverage of spatial, directional, distance-based, and obstacle-aware reasoning patterns (inspired by demonstration-inferred hints).


### Global Uniqueness Across Nonterminals (CRITICAL)
- All primitives must have **distinct names**.
- Each primitive must belong to **exactly one** of the nonterminals:
  - `"START"`
  - `"LOCAL_PROGRAM"`
  - `"CONDITION"`
- Ownership is determined by: pcfg_insertion.nonterminal ∈ {"START","LOCAL_PROGRAM","CONDITION"}
- A primitive’s name may appear **only** in the productions of its owning nonterminal.
- If a primitive has `"nonterminal": "CONDITION"`, it may appear *only* in the CONDITION production.
- If `"nonterminal": "LOCAL_PROGRAM"`, it may appear *only* in LOCAL_PROGRAM.
- If `"nonterminal": "START"`, it may appear *only* in START.
- **No primitive may appear in more than one nonterminal.**
- **No primitive may be repeated across START, LOCAL_PROGRAM, and CONDITION.**
- No primitive may exist solely to combine Boolean results of other primitives.

### Distribution
- **3–4 recursive combinators**:
- Must accept at least one CONDITION or LOCAL_PROGRAM argument.
- Must have exactly one fixed signature.
- At least one must take CONDITION.
- At least one must take LOCAL_PROGRAM.
- **1–2 base-case primitives**:
- May take only VALUE / DIRECTION / VALUE_INT.
- Must not take CONDITION or LOCAL_PROGRAM.
- Base-case primitives may not belong to START.

### Meaningful Observation Access
- Every primitive must index into `obs` with bounds checks.
- No primitive may perform Boolean glue (`and`, `or`, `not`) on outputs of other primitives.

### Prohibited trivial primitives
- No primitive may be a Boolean combiner in disguise...

### Python Stub Requirements
- Signature:
`def NAME(arg1, arg2, ..., cell, obs):`
- Must check `if cell is None: return False`
- Only allowed:
  - indexing `obs[r, c]`
  - arithmetic, comparisons
  - bounded for-loops  
- No helper functions, no recursion, no placeholders.
- No hardcoded obs values (must compare obs[...] only to VALUE arguments).

---

## DEMONSTRATION-INFERRED FEATURES (HINTS)

Below is a summary of patterns extracted from a set of expert trajectories.
These are NOT DSL primitives, but they describe spatial relations frequently
relevant to decision-making.

### High-frequency relational patterns:
- Agent frequently positions itself directly beneath the falling target, aligning along the same vertical (y-axis) column.
- Agent often moves to intercept the target before it reaches hazardous tiles (fire).
- Agent avoids positioning itself on or adjacent to fire tiles.
- Agent sometimes positions itself on the only available safe (non-fire, non-blocked) tile beneath the target’s projected path.

### Useful directional / asymmetry relations:
- Agent’s movement is primarily vertical (along the y-axis) to match the target’s descent, with horizontal (x-axis) adjustments to align with the target’s column.
- When the target is closer to the left or right edge, the agent moves horizontally to match the target’s lateral position.
- Agent responds to asymmetries in fire/block placement, preferring columns with clear paths from the target to the ground.
- If the target is above a cluster of hazards, the agent moves to the nearest safe landing zone in the same row or column.

### Example state–action correlations:
- When the target is directly above a fire tile, the agent moves to the nearest adjacent safe tile in the same row.
- If there is a single clear column between hazards, the agent moves to that column to intercept the target.
- When the target is descending above a gap between hazards, the agent positions itself at the bottom of that gap.
- If the target is above a blocked tile (gray), the agent does not attempt to intercept directly below but seeks the nearest accessible safe tile.

### Frequently observed local spatial configurations:
- Agent and target aligned vertically with no hazards between them.
- Agent positioned at the edge of a contiguous block of fire tiles, intercepting the target at the first available safe tile.
- Agent occupying a single isolated safe tile surrounded by hazards, directly beneath the target’s path.
- Agent and target both near the grid boundary, with the agent using the edge as a constraint for movement.

### Observed distance thresholds or step ranges:
- Agent begins lateral movement when the target is several rows above the hazard layer (often 2–4 tiles away from hazards).
- Agent completes horizontal alignment before the target reaches the last 1–2 rows above the hazard layer.
- Agent rarely moves more than a few tiles horizontally unless the only safe path is at the far edge.
- Agent’s vertical position is less important until the target nears the hazard layer, at which point precise alignment is prioritized.

---

## GRAMMAR REQUIREMENTS

Nonterminals:  
["START", "LOCAL_PROGRAM", "CONDITION", "DIRECTION", "VALUE", "VALUE_INT"]


Terminals: the names of all primitives.

---

### 1. START Production (STRICT)
- START is a normal nonterminal following uniqueness rules.
- Only primitives with `"pcfg_insertion.nonterminal": "START"` may appear in START.
- START must have **≥2 alternatives**.
- Each START alternative must:
  - Call a START-owned primitive
  - Contain at least one argument that is CONDITION or LOCAL_PROGRAM
  - End with `a, s`
- No lambdas in START.
- Base-case primitives may not be START-owned.

START alternatives must be constructed mechanically:
1. Take a primitive whose owning nonterminal is `"START"`.
2. Read its args list in order.
3. Replace each arg with the corresponding NT name.
4. Emit: `"PRIM(NT1, NT2, ..., a, s)"`.

---

### 2. LOCAL_PROGRAM Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "LOCAL_PROGRAM"` may appear in LOCAL_PROGRAM.
- LOCAL_PROGRAM must contain:
  1. The literal alternative: `"CONDITION"`
  2. ≥1 recursive lambda alternative using LOCAL_PROGRAM arguments.
- Format for lambda alternatives:
  `"lambda cell, obs: PRIM(ARG1, ARG2, ..., cell, obs)"`.
- LOCAL_PROGRAM may not include base-case primitives.

---

### 3. CONDITION Production (STRICT)
- Only primitives with `"pcfg_insertion.nonterminal": "CONDITION"` may appear in CONDITION.
- CONDITION must contain:
  - ≥3 alternatives total
  - ≥2 recursive alternatives using CONDITION arguments
  - ≥1 base-case alternative
- CONDITION may **not** contain primitives expecting LOCAL_PROGRAM arguments.
- Base-case primitives may only appear here.

---

### 4. Other Nonterminals
"DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)"
"VALUE": "{OBJECT_TYPES}"
"VALUE_INT": "1 | 2 | 3 ..." 


---

## GLOBAL ARGUMENT CONSISTENCY RULES

For each primitive:
1. Use exactly the number of args listed in its `args` array.
2. Use nonterminal names matching argument types in order.
3. Do not reorder, drop, or add arguments.
4. Production string must match the primitive’s name exactly.
5. No duplicate appearances within a nonterminal. 
  - Repeating the same primitive in multiple alternatives of the same nonterminal is forbidden.



---

## PROGRAM COMPLEXITY REQUIREMENT
The grammar must generate **≥1000** distinct programs through recursive expansion.  
This requires:
- START: ≥2 recursive branches
- LOCAL_PROGRAM: ≥1 recursive branch
- CONDITION: ≥2 recursive branches

---

## OUTPUT FORMAT

- `args` **must** be a JSON array of objects, each with string fields `"name"` and `"type"` (e.g., `[{"name": "cond", "type": "CONDITION"}]`). Never write `args` as a string or any other structure.

{
"proposal": [
{
"rationale_short": "...",
"name": "...",
"type_signature": "(Cell, Obs) -> Bool",
"args": [...],
"semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef NAME(...):\n ...",
"pcfg_insertion": {
"nonterminal": "START" | "LOCAL_PROGRAM" | "CONDITION",
"production": "lambda cell, obs: NAME(..., cell, obs)" // Except START, which uses no lambda
}
}
// exactly all primitives in totall
],
"updated_grammar": {
"nonterminals": [...],
"terminals": [...],
"productions": {
"START": "... | ...",
"LOCAL_PROGRAM": "... | ...",
"CONDITION": "... | ...",
"DIRECTION": "...",
"VALUE": "...",
"VALUE_INT": "1 | 2 | 3 ..."
}
}
}


---

## FINAL VALIDATION CHECKLIST (MANDATORY)
Before returning your answer, ensure:
- Each primitive appears in exactly ONE NT’s productions.
- No primitive repeats across START, LOCAL_PROGRAM, CONDITION.
- START uses only its own primitives, never CONDITION/LOCAL_PROGRAM ones.
- LOCAL_PROGRAM includes `"CONDITION"` + ≥1 recursive lambda.
- CONDITION and LOCAL_PROGRAM have lambda expressions. NO lambda in START.
- CONDITION includes ≥3 alternatives, ≥2 recursive, ≥1 base case.
- At least one combinator takes CONDITION; at least one takes LOCAL_PROGRAM.
- All stubs index obs with bounds checks.
- ALL computed coordinates (neighbor_r, new_r, etc.) are bounds-checked before use
- Grammar generates ≥1000 programs.
- Python stubs are complete (no `...`)
