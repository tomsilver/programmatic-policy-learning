## System Prompt
You are an expert programmer and problem solver.
Your task is to write a correct and general policy in Python.
You may define helper functions if needed.
Return only executable Python code.

--

## Environment description:

- The environment is a grid-based board game implementing a simplified checkmate scenario.
- The observation `obs` is a 2D Python NumPy array (rows × columns).
  - Do not use boolean checks such as `if obs`, `if not obs`, or `obs == []`. 
- Each cell contains exactly one of the following symbols:

  - empty
  - black_king
  - white_king
  - white_queen
  - highlighted_white_king
  - highlighted_white_queen


## Game Dynamics and Rules

- The game takes place on a finite 2D grid representing a simplified chessboard.
- There are three pieces in the environment:
  - **Black king** (the opponent and target),
  - **White king** (controlled by the agent),
  - **White queen** (controlled by the agent).
- On each turn, **only one white piece is movable**, indicated by a highlighted cell (`highlighted_white_king` or `highlighted_white_queen`).
- The agent must select a grid cell corresponding to a legal move for the highlighted white piece.
- Legal movement rules (e.g., how kings and queens move, captures, checks) are enforced internally by the environment and are **not explicitly provided** to the policy.
- The black king moves according to the environment’s internal rules and is not directly controlled by the agent.

### Objective and Termination

- The goal is to **deliver checkmate** to the black king.
- A checkmate occurs when the black king has **no legal moves** and is under unavoidable threat according to the environment’s rules.
- The episode ends successfully when the environment detects a checkmate.
- The episode ends unsuccessfully if the game reaches a terminal state that is not checkmate (e.g., stalemate or draw conditions handled internally).

### Interaction Constraints

- The agent does not explicitly issue “check” or “capture” commands.
- The agent does not control which white piece is active on a given turn.
- Selecting an invalid cell, an illegal move, or a non-highlighted piece results in no effect.
- The policy must rely solely on the spatial configuration of pieces and highlighted cells in the observation.

### Key Implications for Decision-Making

- The agent must infer effective play purely from board geometry and piece positioning.
- Progress toward checkmate typically involves:
  - Restricting the black king’s available movement,
  - Coordinating the white king and queen,
  - Using board edges and corners as natural constraints.
- All enforcement of legality, turn order, and win conditions is handled by the environment, not the policy.

--

## Action space:

The policy must return a tuple (row, column) corresponding to a cell in the grid.

- (row, column) must be a valid cell location within the grid bounds.
- Selecting a cell represents choosing that cell as the agent’s action.
- The environment defines which actions are legal and how they affect the game state.
- Selecting an invalid or illegal cell has no effect.

--

## Task Description
Task:
Deliver checkmate to the black king.
The episode ends successfully when the black king is checkmated.
The episode ends unsuccessfully if the environment reaches a terminal non-checkmate state.

--

## Expert-Derived Hints

Below is a summary of patterns extracted from a set of expert trajectories. These are NOT DSL primitives, but they describe spatial relations frequently relevant to decision-making.

CORE CONSISTENT STRATEGY:  
The agent’s strategy is to prioritize interaction with key pieces—most notably the white queen—by selecting their positions when available. When a key piece is not directly targetable, the agent instead selects empty cells that are contextually significant due to their alignment or proximity to major objects (typically the kings), favoring cells that lie between, adjacent to, or in effective alignment with these pieces. Throughout, the agent avoids arbitrary or off-path movements and does not engage with irrelevant or blocked cells.

CONTEXT-DEPENDENT BEHAVIORS:  
- If the white queen is present and selectable, the agent targets its location first.  
- If the queen is not present or selectable, the agent selects empty cells that are strategically aligned—frequently those between or adjacent to the kings, and often on the same row or column to maximize influence or control over their spatial relationship.  
- The preference for the precise alignment (row versus column) or direct adjacency depends on the current arrangement of the pieces.

INCIDENTAL/CONTRADICTORY ELEMENTS DISCARDED:  
- Selection of the queen’s own cell when occupied may result from the environment’s rules rather than a distinct strategy.  
- No evidence supports responses to obstacles or boundaries, so interpretations involving obstacle navigation are not part of the core strategy.  
- No preference for arbitrary empty squares far from key objects is supported.

UNIFIED ENVIRONMENT-LEVEL DESCRIPTION:  
The agent systematically prioritizes interactive engagement with principal pieces—most notably the white queen—by acting directly on their positions when available. Otherwise, it selects spatially significant empty cells that are closely aligned, adjacent, or centered relative to both kings, maximizing its strategic positioning with respect to the major pieces' configuration. This approach adapts dynamically based on the arrangement of key pieces, always emphasizing proximity, alignment, and influence over the relevant objects, and disregards irrelevant or distant cells.

--

## Output Format Constraint

Return ONLY the Python code for the policy, wrapped in a Markdown fenced code block
that starts with ```python and ends with ```.

The code must define a function with the following signature:

```python
def policy(obs):
    ...
    return action
```

Where `action` is:
- a tuple (row, col)

You may define helper functions inside the code.
Do not use external libraries.
Do not include explanations, comments, or markdown.
Return only executable Python code.
Do not include any text outside the code block.

--

## Notes on Checkmate Assumptions

- No Checkmate-specific helper functions are provided.
- The policy must infer piece locations and roles directly from the grid observation.
- Highlighted cells provide cues about valid actions but do not expose the underlying rules.
- The policy does not have access to the environment’s transition or legality rules.
- All game logic, beyond interpreting the grid observation, is handled by the environment.
