## SYSTEM

You are designing a type-safe DSL primitive for Logical Programmatic Policies in Generalization Grid Games.

Your job is to propose **ONE** new primitive and also output the **FULL updated grammar** that results from inserting that primitive into the current grammar. Output a single STRICT JSON object only. No prose, comments, or markdown.
In your reasoning process, analyze the existing DSL primitives and infer what capabilities or compositional patterns are currently under-represented. Then hypothesize which primitive would make the program search space more efficient or compact.

SYSTEM

You design ONE type-safe DSL primitive for Logical Programmatic Policies in Generalization Grid Games and output a single STRICT JSON object. No prose, no Markdown, no comments.

You MUST follow every constraint below. If any constraint would be violated, revise your idea until it satisfies all constraints.
## USER:

### Task

There is a partial DSL used for learning logical policies in grid-based environments. Propose ONE new primitive that:

- Improves DSL utility (generalization, expressiveness, search efficiency)
- Is type-safe and executable
- Composes naturally with the existing grammar
- Fits into the specified nonterminal slot

In addition, return the **FULL updated grammar** reflecting the insertion of your primitive.

---

### DSL Type System

PROGRAM        := Bool
LOCAL_PROGRAM  := (Cell, Obs) -> Bool
CONDITION      := (Cell, Obs) -> Bool
DIRECTION      := (Int, Int)
VALUE          := Int
CELL           := (Int, Int)
OBS            := Observation
ACTION         := DiscreteAction
STATE          := Observation

### Current Grammar

Nonterminals:
START, LOCAL_PROGRAM, CONDITION, DIRECTION, VALUE = range(5)

Terminals:
at_action_cell, cell_is_value, shifted, scanning

Productions:
START -> at_action_cell(LOCAL_PROGRAM, a, s) # s =state, a=action

LOCAL_PROGRAM ->
CONDITION | lambda cell,o : shifted(DIRECTION, CONDITION, cell, obs)

CONDITION ->
lambda cell,o: cell_is_value(VALUE, cell, obs)

DIRECTION -> (1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)

VALUE ->
{OBJECT_TYPES}   # e.g., {'tpn.EMPTY','tpn.TOKEN','None'} for Nim

### Existing Primitive Summaries (Terminals)

cell_is_value(v, cell, obs): True if the object at cell has value v.

```python
def cell_is_value(value: Any, cell: tuple[int, int] | None, obs: np.ndarray) -> bool:
    """Check if a cell contains a specific value."""
    if cell is None or value is None or out_of_bounds(cell[0], cell[1], obs.shape):
        return False
    return obs[cell[0], cell[1]] == value

```


at_action_cell(prog, a, s): True if prog holds at the action-conditioned cell in s.

```python
def at_action_cell(
    local_program: Callable, cell: tuple[int, int] | None, obs: np.ndarray
) -> bool:
    """Execute a local program at the action cell position."""
    return local_program(cell, obs)

```

shifted(dir, prog, cell, obs): runs the local program prog on the cell obtained by moving cell one step in direction dir within the observation obs.

```python
def shifted(
    direction: tuple[int, int],
    local_program: Callable,
    cell: tuple[int, int] | None,
    obs: np.ndarray,
) -> bool:
    """Execute a local program at a shifted cell position."""
    if cell is None:
        new_cell = None
    else:
        new_cell = (cell[0] + direction[0], cell[1] + direction[1])
    return local_program(new_cell, obs)
```

scanning(dir, p_true, p_block, cell, obs): Walk along dir; succeed if p_true matches before p_block.  (omit if removed)

```python
def scanning(
    direction: tuple[int, int],
    true_condition: Callable,
    false_condition: Callable,
    cell: tuple[int, int] | None,
    obs: np.ndarray,
    max_timeout: int = 50,
) -> bool:
    """Scan in a direction until a condition is met."""
    if cell is None:
        return False

    current_cell = cell
    for _ in range(max_timeout):
        current_cell = (current_cell[0] + direction[0], current_cell[1] + direction[1])

        if true_condition(current_cell, obs):
            return True

        if false_condition(current_cell, obs):
            return False

        # Prevent infinite loops
        if out_of_bounds(current_cell[0], current_cell[1], obs.shape):
            return False

    return False

### Existing helper function used in the implementations:

out_of_bounds(r, c, shape) → Returns `True` if `(r, c)` lies outside the grid defined by `shape` (rows × cols); otherwise `False` .

```python
def out_of_bounds(r: int, c: int, shape: tuple[int, ...]) -> bool:
    """Check if coordinates are outside the grid bounds."""
    if len(shape) < 2:
        return True  # Invalid shape
    return r < 0 or c < 0 or r >= shape[0] or c >= shape[1]

```

### Environment Description

Generalization Grid Games are a family of grid-world environments designed for studying compositional generalization and programmatic policy learning. It has a few different tasks/games.

Each game is played on a discrete 2-D grid and shares a unified state-action structure:

- **State / Observation (Obs):**
    
    A full grid where each cell contains a discrete value representing an object type (e.g., token, wall, agent).
    
    The observation is the full grid.
    
- **Action:**
    
    Selecting a single grid cell — i.e., “clicking” on the grid, which represents an atomic action location.
    
- **Transition:**
    
    Deterministic grid update defined by each game’s rule (e.g., removing, moving, or swapping objects).
    
- **Example games:**
    - **TwoPileNim:** Each cell may hold a token (like: tpn.EMPTY, tpn.TOKEN, or None). Clicking a cell removes a token from that location, following the rules of a simplified spatial Nim game.
    - **Chase:** The agent moves toward a target while avoiding walls.
    - **CheckmateTactic:** Move a piece to put the opponent’s king in checkmate within a limited number of turns.
    - **StopTheFall:** Place supports to prevent falling blocks from reaching the bottom of the grid.
    - **ReachForTheStar:** Navigate the agent to collect the star while avoiding obstacles.
    - **FenceIn:** Build barriers to surround or trap a moving target inside a bounded region.

### Example DSL Programs

1. at_action_cell(lambda c, o: shifted((1, 0), lambda c, o: cell_is_value(1, c, o), c, o), a, s): Checks whether, for the cell where the current action a occurs in state s, the cell immediately to its right has the grid value 1.
2. at_action_cell(lambda c,o: cell_is_value(2,c,o), a, s): Checks whether the cell on which the current action `a` operates in state `s` has the grid value 2.
3. lambda c, o: shifted((0, -1), lambda c, o: cell_is_value(1, c, o), c, o): Returns True if the cell immediately to the left of the current cell contains the value 1.


### Output Format (STRICT JSON)

{
"proposal": {
"rationale_short": "≤20 words on why this helps search.",
"name": "STRING_SNAKE_CASE",
"type_signature": "SIGNATURE",                // must evaluate to Bool with (cell, obs)
"args": [{"name":"...","type":"..."}],
"semantics_py_stub": "def NAME(ARG1, ARG2, ..., cell, obs):\\n    ...",  // pure, deterministic
"pcfg_insertion": {
"nonterminal": "START|LOCAL_PROGRAM|CONDITION|DIRECTION|VALUE",
"production": "NAME(ARG1, ARG2, ..., cell, obs) | lambda cell,o: NAME(ARG1,ARG2,...,cell,o)", #<INSERTED_RULE>
}
},
"updated_grammar": {
"nonterminals": ["START","LOCAL_PROGRAM","CONDITION","DIRECTION","VALUE"],
"terminals": ["at_action_cell","cell_is_value","shifted", "scanning", "NAME"],
"productions": {
"START": "at_action_cell(LOCAL_PROGRAM, a, s) | <INSERTED_RULE>",
"LOCAL_PROGRAM": "CONDITION | lambda cell, obs : shifted(DIRECTION, CONDITION, cell, obs) | <INSERTED_RULE>",
"CONDITION": "lambda cell, obs: cell_is_value(VALUE, cell, obs) | <INSERTED_RULE>",
"DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)",
"VALUE": "{OBJECT_TYPES}"
},
}
}

**Rules for building updated_grammar:**

- Add the new primitive's `NAME` to terminals.
- Insert exactly one new production alternative under the specified nonterminal (from `pcfg_insertion.nonterminal`).
- Do not modify other nonterminals or terminals.
- Rules can be inserted at any of the placeholders specified with “<INSERTED_RULE>”.
- Keep formatting and ordering consistent with the current grammar.

### Safety Requirements

- Deterministic and side-effect-free
- No dependencies. Do not call or define any helpers inside semantics_py_stub. Your stub may use only its own parameters, literals, basic boolean/arithmetic operators, and simple Python control flow; no imports, no globals, no external identifiers.
- The python stub can also use other terminals or nonterminal defined above.
- Must type-check
    - Results may be any well-typed expression of the declared return type, literals, composed primitives.
    - For python stub, no type annotation is needed.
- Always start your python stub with this import: "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *" (the code should start immediately at its next line)
- Be careful that cell values can be None too. Check for that to avoid syntax errors in the python stub.
- Do not combine or modify Nonterminal names (e.g., def x(CONDITIONS) or def x(CONDITION1, CONDITION2) => THESE ARE FORBIDDEN) — only use existing single Nonterminals as defined in the grammar.
- Arguments in the 'production' field can only be among the Nonterminals (like: CONDITION, DIRECTION, VALUE, LOCAL_PROGRAM) or fixed variables (like: cell, obs, a, s).
- Do not use import statements; the code must run with only the provided stubs.
- Output only valid JSON, nothing else.
- Output must be a single valid JSON object with exactly the two top-level keys: `"proposal"` and `"updated_grammar"`.
- The `updated_grammar` must be a self-contained full grammar (not a diff), consistent with the insertion described in `proposal.pcfg_insertion`.

### Argument Usage Rule

- Each argument listed in "args" must correspond to an existing nonterminal in the grammar, or one of these predefined argument types:
    - "Int" → use the nonterminal VALUE_INT
    - "VALUE" → use the nonterminal VALUE
    - "DIRECTION" → use the nonterminal DIRECTION
    - "LOCAL_PROGRAM" → use the nonterminal LOCAL_PROGRAM
    - "CONDITION" → use the nonterminal CONDITION
- You must not use literal names like "max_steps" or "threshold" directly in the "production" string.
- Instead, map them to the corresponding nonterminal:
    - Example:
    "args": [{"name": "max_steps", "type": "Int"}] ⇒ "production": "loop_detection(VALUE_INT, cell, obs)".
- If the grammar does not already contain that nonterminal (e.g. VALUE_INT), add it to "nonterminals" and define its expansion rule explicitly, e.g.:
"VALUE_INT": "1 | 2 | 3 | 4 | 5".
- Never insert undeclared variable names directly (e.g., max_steps, threshold, etc.) into productions.

### Final Note

Propose anything that improves DSL utility and fits the type + grammar constraints.