## SYSTEM

You are an expert language designer for program synthesis systems.
Your task is to design a complete, type-safe DSL grammar for Logical Programmatic Policies in grid-based games.

Output ONLY a single valid JSON object. No prose, comments, or markdown.

## OUTPUT FORMAT - CRITICAL

1. **No trailing commas**: 
   ✓ CORRECT: `{"key": "value"}`
   ✗ WRONG: `{"key": "value",}`

2. **Escape quotes in strings**:
   ✓ CORRECT: `"semantics": "def foo():\n    return \"hello\""`
   ✗ WRONG: `"semantics": "def foo():\n    return "hello""`

3. **Use \n for newlines in Python code**:
   ✓ CORRECT: `"semantics_py_stub": "def foo():\n    pass"`
   ✗ WRONG: Actual newlines in string values

4. **Complete the entire JSON**:
   - Don't stop mid-response
   - Ensure all brackets/braces are closed
   - End with proper `}`

5. **No comments in JSON**:
   ✗ WRONG: `{"key": "value"} // this is a comment`


- NO markdown code blocks (no ```json or ```)
- NO explanatory text before or after
- NO comments or additional prose
- ONLY the raw JSON object starting with { and ending with }
- The output must be directly parsable by Python's json.loads()

**Example of CORRECT output:**
{"proposal": [...], "updated_grammar": {...}}

**Examples of INCORRECT output:**
- ```json\n{"proposal": ...}\n```  ❌
- Here is the JSON: {"proposal": ...}  ❌
- {"proposal": ...}\n\nExplanation: ...  ❌

Your entire response should be valid JSON that can be immediately parsed.

---

## Environment Context

Generalization Grid Games (GGG) are discrete 2D environments where:
- Each cell contains a symbolic value (e.g., token, wall, agent, empty)
- Actions correspond to selecting a grid cell
- Games include: TwoPileNim, Chase, CheckmateTactic, StopTheFall, ReachForTheStar, FenceIn
- All transitions are deterministic and rule-based

---

## Type System
PROGRAM        := Bool
LOCAL_PROGRAM  := (Cell, Obs) -> Bool
CONDITION      := (Cell, Obs) -> Bool
DIRECTION      := (Int, Int)
VALUE          := ObjectType
ObjectType     := {OBJECT_TYPES}
 

**Note on Integer Arguments:**
- If your primitives need integer parameters (e.g., distance, radius, count), use type "Int"
- You must then define a nonterminal "VALUE_INT" in your grammar with concrete integer values
- Example: "VALUE_INT": "1 | 2 | 3"

---

## Task

Design exactly FIVE new primitive functions that:
1. Each has type signature: `(Cell, Obs) -> Bool`
2. Are deterministic, terminating, and side-effect-free
3. Enable spatial, relational, or logical reasoning in grid environments
4. Compose naturally to create diverse programs

Then provide a COMPLETE GRAMMAR that integrates these primitives.

---

## CRITICAL Grammar Requirements

### Reachability & Program Space
Your grammar MUST satisfy ALL of these structural constraints:

1. **START must reach CONDITION or LOCAL_PROGRAM**
   - START cannot expand only to VALUE or other terminals
   - START must reference at least one primitive that uses CONDITION or LOCAL_PROGRAM

2. **Recursion is MANDATORY**
   - At least one nonterminal must have recursive structure
   - Valid patterns:
     * `CONDITION → ... CONDITION ...`
     * `LOCAL_PROGRAM → ... LOCAL_PROGRAM ...`
     * `CONDITION → ... LOCAL_PROGRAM → ... CONDITION`
   - This ensures unbounded program space

3. **Branching is MANDATORY**
   - CONDITION must have ≥2 alternative productions (use `|` separator)
   - At least one production must use a different primitive or composition

4. **All nonterminals must be reachable from START**
   - VALUE and DIRECTION must appear in productions reachable from START
   - No isolated or dead nonterminals

5. **Program space must be sufficiently large**
   - The grammar must generate ≥100 distinct programs from START
   - Avoid grammars where START has only one path with finite expansions

### Invalid Grammar Example (DO NOT DO THIS)
```json
{
  "START": "is_target(VALUE, a, s)",  // ❌ Only expands VALUE (3 programs total)
  "CONDITION": "lambda cell, obs: is_empty(cell, obs)"  // ❌ Not reachable from START
}
```

### Valid Grammar Example (DO THIS)
```json
{
  "START": "has_neighbor(VALUE, DIRECTION, a, s)",  // ✓ Uses VALUE, DIRECTION
  "CONDITION": "lambda cell, obs: has_neighbor(VALUE, DIRECTION, cell, obs) | lambda cell, obs: check_pattern(CONDITION, DIRECTION, cell, obs)",  // ✓ Recursive, branching
  "LOCAL_PROGRAM": "CONDITION"  // ✓ Reachable
}
```

---

## Primitive Implementation Rules

### Python Stub Requirements
- Start with: `from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *`
- Function signature: `def NAME(ARG1, ARG2, ..., cell, obs):`
- **CRITICAL**: `obs` is a raw 2D NumPy array
  - ✓ Allowed: `obs[r, c]`, `obs[r, c] == value`, indexing
  - ✗ FORBIDDEN: `obs.width`, `obs.height`, `obs.grid`, `obs.get()`, any attributes/methods
- Always check `cell is not None` before indexing to avoid exceptions
- Use only: literals, arithmetic/boolean operators, bounded loops
- No helper functions, no recursion in implementation
- Must be complete and executable (no placeholders like `...` or `# TODO`)

### CRITICAL: Do NOT hardcode or assume obs values

**You do NOT know what values are in obs.**
- obs values come from {OBJECT_TYPES} which vary by game
- NEVER hardcode strings like "empty", "wall", "token", "agent", etc.
- ONLY compare obs values against the function arguments passed in

---

## Grammar Production Rules

### START Production
- **EXACT FORMAT**: `"START": "FUNCTION_NAME(TYPE_1, TYPE_2, ..., a, s)"`
- Final five arguments MUST be literally `a, s` (not cell, obs, or any other name)
- TYPE_i ∈ {VALUE, CONDITION, LOCAL_PROGRAM, DIRECTION, Int}
- No lambda in START
- Must use at least one primitive that creates program diversity

### CONDITION/LOCAL_PROGRAM Productions
- **EXACT FORMAT**: `lambda cell, obs: FUNCTION_NAME(NONTERMINAL_1, NONTERMINAL_2, ..., cell, obs)`
- Arguments before `cell, obs` must be DSL nonterminals: VALUE, CONDITION, LOCAL_PROGRAM, DIRECTION, Int
- ✗ FORBIDDEN: variable names like `value`, `direction`, `prog`, `object_type`
- ✓ REQUIRED: Only nonterminal names as arguments
- Use `|` to separate multiple alternatives (for branching)
- Each primitive should appear in at least one reachable production

#### Valid Argument Types in Productions
  In grammar productions (START, CONDITION, LOCAL_PROGRAM), the ONLY valid nonterminal references are:
  - VALUE ✓
  - CONDITION ✓
  - LOCAL_PROGRAM ✓
  - DIRECTION ✓
  - VALUE_INT ✓ (if using Int type in args)

  **FORBIDDEN in productions:**
  - Int ❌ (use VALUE_INT instead)
  - Cell ❌
  - Obs ❌
  - Any lowercase type names ❌


### Nonterminal Definitions
- `DIRECTION`: Must include all 8 directions: `(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)`
- `VALUE`: `{OBJECT_TYPES}` (expands to game-specific object types)
- `LOCAL_PROGRAM`: Must be defined (typically: `CONDITION` or more complex)

#### Integer Type Handling
- If ANY primitive uses `Int` as an argument type:
  1. Add "VALUE_INT" to the `nonterminals` list
  2. Define the production: `"VALUE_INT": "1 | 2 | 3"` (or appropriate range)
  3. Use `VALUE_INT` (not `Int`) in all grammar productions
- Example primitive with Int: `{"name": "arg", "type": "Int"}`
- Example grammar production: `lambda cell, obs: my_func(VALUE_INT, cell, obs)`

---

## Output Format
```
{
  "proposal": [
    {
      "rationale_short": "Brief explanation (≤20 words) of primitive's purpose",
      "name": "FUNCTION_NAME_1",
      "type_signature": "(Cell, Obs) -> Bool",
      "args": [
        {"name": "descriptive_arg_name", "type": "TYPE_1"},
        {"name": "descriptive_arg_name", "type": "TYPE_2"}
      ],
      "semantics_py_stub": "from programmatic_policy_learning.dsl.primitives_sets.grid_v1 import *\ndef FUNCTION_NAME_1(arg1, arg2, ..., cell, obs):\n    if cell is None:\n        return False\n    # Complete implementation here\n    return True",
      "pcfg_insertion": {
        "nonterminal": "CHOSEN_NONTERMINAL",
        "production": "lambda cell, obs: FUNCTION_NAME_1(arg1, arg2, ..., cell, obs)"
      }
    }
    // ... repeat for FUNCTION_NAME_2 through FUNCTION_NAME_5
  ],
  "updated_grammar": {
    "nonterminals": ["START", "LOCAL_PROGRAM", "CONDITION", "DIRECTION", "VALUE", "VALUE_INT"], //VALUE_INT is optional
    "terminals": ["FUNCTION_NAME_1", "FUNCTION_NAME_2", "FUNCTION_NAME_3", "FUNCTION_NAME_4", "FUNCTION_NAME_5"],
    "productions": {
      "START": "FUNCTION_NAME_X(arg1, arg2, ..., a, s)",
      "LOCAL_PROGRAM": "lambda cell, obs: FUNCTION_NAME_Y(arg1, arg2, ..., cell, obs) | ...",
      "CONDITION": "lambda cell, obs: FUNCTION_NAME_Z(arg1, arg2, ..., cell, obs) | lambda cell, obs: FUNCTION_NAME_W(arg1, arg2, ..., cell, obs) | ...",
      "DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)",
      "VALUE": "{OBJECT_TYPES}",
      "VALUE_INT": "1 | 2 | 3", //optional
    }
  }
}
```

### Example Distribution Pattern
The example shows 4 out of 5 primitives in CONDITION. You may:
- Place primitives across multiple nonterminals (CONDITION, LOCAL_PROGRAM, or even START)
- Use different argument patterns to create diversity
- Ensure at least 2-3 primitives provide recursive or compositional structure
- Have some primitives serve as base cases (simpler, non-recursive)
- The key is ensuring reachability and sufficient program space, not using all primitives in one place


---

## Validation Checklist

Before submitting, verify:
- [ ] START references a primitive (not just VALUE)
- [ ] At least one recursive production exists
- [ ] CONDITION has ≥2 alternatives (uses `|`)
- [ ] All nonterminals in `nonterminals` list appear in `productions`
- [ ] VALUE and DIRECTION are used in reachable productions
- [ ] Both primitives appear in the grammar
- [ ] No `obs.attribute` or `obs.method()` in Python stubs
- [ ] Python stubs are complete (no `...` placeholders)
- [ ] Grammar can generate ≥100 programs from START
- [ ] If any primitive uses Int type, "VALUE_INT" is in nonterminals and productions
- [ ] All grammar productions use VALUE_INT (not Int) as the nonterminal reference

---

## Goal

Design five complementary primitives that enable expressive spatial reasoning while ensuring the grammar produces a large, diverse program space for synthesis.