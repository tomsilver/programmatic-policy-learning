## SYSTEM

You are designing a type-safe DSL primitive for Logical Programmatic Policies (LPP) in Generalization Grid Games. 

Your job is to propose **ONE** new primitive and also output the **FULL updated grammar** that results from inserting that primitive into the current grammar. Output a single STRICT JSON object only. No prose, comments, or markdown.
 

## USER:

### Task

There is a partial DSL used for learning logical
policies in grid-based environments. Propose ONE new primitive that:

- Improves DSL utility (generalization, expressiveness, search efficiency)
- Is type-safe and executable
- Composes naturally with the existing grammar
- Fits into the specified nonterminal slot

In addition, return the **FULL updated grammar** reflecting the insertion of your primitive.
****

### DSL Type System

PROGRAM        := Bool
LOCAL_PROGRAM  := (Cell, Obs) -> Bool
CONDITION      := (Cell, Obs) -> Bool
DIRECTION      := (Int, Int)
VALUE          := Int
CELL           := (Int, Int)
OBS            := Observation
ACTION         := DiscreteAction
STATE          := Observation

### Current Grammar

Nonterminals:
START, LOCAL_PROGRAM, CONDITION, DIRECTION, VALUE

Terminals:
at_cell_with_value, at_action_cell, cell_is_value, scanning

Productions:
START ->
at_cell_with_value(VALUE, LOCAL_PROGRAM, STATE)
| at_action_cell(LOCAL_PROGRAM, ACTION, STATE)

LOCAL_PROGRAM ->
CONDITION 

CONDITION ->
cell_is_value(VALUE, cell, obs)
| scanning(DIRECTION, LOCAL_PROGRAM, LOCAL_PROGRAM, cell, obs)

DIRECTION ->
(1,0) | (0,1) | (-1,0) | (0,-1)
| (1,1) | (-1,1) | (1,-1) | (-1,-1)

VALUE ->
{OBJECT_TYPES}   # e.g., {'tpn.EMPTY','tpn.TOKEN','None'} for Nim game

### Existing Primitive Summaries

cell_is_value(v, cell, obs): True if the object at cell has value v.

```python
def cell_is_value(value: Any, cell: tuple[int, int] | None, obs: np.ndarray) -> bool:
    """Check if a cell contains a specific value."""
    if cell is None or value is None or out_of_bounds(cell[0], cell[1], obs.shape):
        return False
    return obs[cell[0], cell[1]] == value

```

at_cell_with_value(v, prog, s): True if prog holds at a cell with value v in s.

```python
def at_cell_with_value(value: Any, local_program: Callable, obs: np.ndarray) -> bool:
    """Execute a local program at the first cell containing a specific
    value."""
    matches = np.argwhere(obs == value)
    if len(matches) == 0:
        cell = None
    else:
        cell = tuple(matches[0])  # Convert to tuple for consistency
    return local_program(cell, obs)

```

at_action_cell(prog, a, s): True if prog holds at the action-conditioned cell in s.

```python
def at_action_cell(
    local_program: Callable, cell: tuple[int, int] | None, obs: np.ndarray
) -> bool:
    """Execute a local program at the action cell position."""
    return local_program(cell, obs)
```

scanning(dir, p_true, p_block, cell, obs): Walk along dir; succeed if p_true matches before p_block.  (omit if removed)

```python
def scanning(
    direction: tuple[int, int],
    true_condition: Callable,
    false_condition: Callable,
    cell: tuple[int, int] | None,
    obs: np.ndarray,
    max_timeout: int = 50,
) -> bool:
    """Scan in a direction until a condition is met."""
    if cell is None:
        return False

    current_cell = cell
    for _ in range(max_timeout):
        current_cell = (current_cell[0] + direction[0], current_cell[1] + direction[1])

        if true_condition(current_cell, obs):
            return True

        if false_condition(current_cell, obs):
            return False

        # Prevent infinite loops
        if out_of_bounds(current_cell[0], current_cell[1], obs.shape):
            return False

    return False
```

### Environment Description

Generalization Grid Games are a family of grid-world environments designed for studying compositional generalization and programmatic policy learning. It has a few different tasks/games.

Each game is played on a discrete 2-D grid and shares a unified state-action structure:

- **State / Observation (Obs):**
    
    A full grid where each cell contains a discrete value representing an object type (e.g., token, wall, agent).
    
    The observation is the full grid.
    
- **Action:**
    
    Selecting a single grid cell — i.e., “clicking” on the grid, which represents an atomic action location.
    
- **Transition:**
    
    Deterministic grid update defined by each game’s rule (e.g., removing, moving, or swapping objects).
    
- **Example games:**
    - **TwoPileNim:** Each cell may hold a token (like: tpn.EMPTY, tpn.TOKEN, or None). Clicking a cell removes a token from that location, following the rules of a simplified spatial Nim game.
    - **Chase:** The agent moves toward a target while avoiding walls.

### Example DSL Programs

1. at_cell_with_value(1, lambda c,o: cell_is_value(1,c,o), s): Checks whether there exists a cell in state `s` whose grid value is `1` and (redundantly) confirms that same cell’s value is `1`.
2. at_action_cell(lambda c,o: cell_is_value(2,c,o), a, s): Checks whether the cell on which the current action `a` operates in state `s` has the grid value 2.
3. at_cell_with_value(3, lambda c,o: scanning((1,0), P1, P2, c,o), s):  Looks for a cell of value `3` in state `s` such that scanning to the right from that cell finds a cell satisfying P1 and later a cell satisfying P2 **(**P1 and P2 are pure (Cell,Obs)->Bool predicates )

### Output Format (STRICT JSON)

{
"proposal": {
"rationale_short": "≤20 words on why this helps search.",
"name": "STRING_SNAKE_CASE",
"type_signature": "SIGNATURE",                // must evaluate to Bool with (cell, obs)
"args": [{"name":"...","type":"..."}],
"semantics_py_stub": "def NAME(...):\\n    ...",  // pure, deterministic
"pcfg_insertion": {
"nonterminal": "START|LOCAL_PROGRAM|CONDITION|DIRECTION|VALUE",
"production": "NAME(ARG1, ARG2, ..., cell, obs) | lambda cell,o: NAME(ARG1,...,cell,o)",
}
},
"updated_grammar": {
"nonterminals": ["START","LOCAL_PROGRAM","CONDITION","DIRECTION","VALUE"],
"terminals": ["at_cell_with_value","at_action_cell","cell_is_value","scanning","NAME"],
"productions": {
"START": "at_cell_with_value(VALUE, LOCAL_PROGRAM, STATE) | at_action_cell(LOCAL_PROGRAM, ACTION, STATE)",
"LOCAL_PROGRAM": "CONDITION",
"CONDITION": "cell_is_value(VALUE, cell, obs) | scanning(DIRECTION, LOCAL_PROGRAM, LOCAL_PROGRAM, cell, obs) | <INSERTED_OR_REPLACED_RULE>",
"DIRECTION": "(1,0) | (0,1) | (-1,0) | (0,-1) | (1,1) | (-1,1) | (1,-1) | (-1,-1)",
"VALUE": "{OBJECT_TYPES}"
},
}
}

**Rules for building updated_grammar:**

- Add the new primitive's `NAME` to terminals.
- Insert exactly one new production alternative under the specified nonterminal (from `pcfg_insertion.nonterminal`).
- Do not modify other nonterminals or terminals.
- Keep formatting and ordering consistent with the current grammar.

### Safety Requirements

- Deterministic and side-effect-free
- Must type-check
    - Results may be any well-typed expression of the declared return type, literals, composed primitives, or helper-based expressions.(*)
- Output only valid JSON, nothing else.
- Output must be a single valid JSON object with exactly the two top-level keys: `"proposal"` and `"updated_grammar"`.
- The `updated_grammar` must be a self-contained full grammar (not a diff), consistent with the insertion described in `proposal.pcfg_insertion`.

### Final Note

Propose anything that improves DSL utility and fits the type + grammar constraints.